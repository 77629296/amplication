name: CI

on:
  workflow_dispatch:
  push:
    branches: ["**"]
    paths-ignore:
      - "**.md"
      - "renovate.json"
      - ".all-contributorsrc"
  pull_request_target:
    branches: ["master", "release/*", "dependabot"]
    types: [opened, reopened]
    paths-ignore:
      - "**.md"
      - "renovate.json"
      - ".all-contributorsrc"

jobs:
  changes:
    runs-on: ubuntu-20.04
    outputs:
      packages: ${{ toJson(steps.packages.outputs.package_names) }}
    steps:

      - uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: set base to compare
        id: base-head
        run: |
          if [[ "${{ github.event_name }}" == 'pull_request' ]]; then
               echo "::set-output name=value::${{ github.base_ref }}"
          else
               echo "::set-output name=value::origin/master"
          fi
      - run: echo ${{ steps.base-head.outputs.value }}

      - name: get changed folders
        id: changed-folders
        env:
          BASE_HEAD: ${{ steps.base-head.outputs.value }}
        run: |
          echo ::set-output name=folders::$( \

          # Git Diff - Get all changed files from BASE_HEAD 
          git diff $BASE_HEAD --name-only -- 'packages/**' 'ee/packages/**' | 

          # Extract folder names from files path
          grep -Eio "(.+||^)packages.[^\/]+" | 

          # Dedupplicate folders
          uniq |

          # Format results as JSON array
          jq -Rs 'split("\n") | map(select(length > 0))')

      - run: echo ${{ steps.changed-folders.outputs.folders }}

      - name: get package names
        id: packages
        uses: ./.github/actions/get-package-names
        with:
          folders: ${{ steps.changed-folders.outputs.folders }}

      - run: |
          echo "_________________________"
          echo "__________1______________"
          echo "_________________________"
          echo ${{ toJson(steps.packages.outputs.package_names) }}
          echo "_________________________"
          echo "__________2______________"
          echo "_________________________"
          echo ${{ fromJSON(steps.packages.outputs.package_names) }}
          echo "_________________________"
          echo "__________3______________"
          echo "_________________________"
          echo ${{ steps.packages.outputs.package_names }}
  t:
    runs-on: ubuntu-20.04
    needs: [changes]
    steps:
      - run: |
          echo "_________________________"
          echo "__________1______________"
          echo "_________________________"
          echo ${{ toJson(needs.changes.outputs.packages) }}
          echo "_________________________"
          echo "__________2______________"
          echo "_________________________"
          echo ${{ fromJSON(needs.changes.outputs.packages) }}
          echo "_________________________"
          echo "__________3______________"
          echo "_________________________"
          echo ${{ needs.changes.outputs.packages }}

  tests:
    runs-on: ubuntu-20.04
    needs: [changes]
    if: ${{ needs.changes.outputs.packages != '[]' && needs.changes.outputs.packages != '' }}
    timeout-minutes: 45
    strategy:
      matrix:
        package: ${{ fromJson(needs.changes.outputs.packages) }}
        node-version: [14.x, 16.x]
    steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v2
        with:
          node-version: ${{ matrix.node-version }}
      - name: Cache node modules
        uses: actions/cache@v2
        with:
          path: |
            ~/.npm
            node_modules
            */*/node_modules
          key: PUSH-${{ runner.os }}-${{matrix.node-version}}-${{matrix.package.folder}}-${{ hashFiles(format('{0}/package-lock.json',matrix.package.folder)) }}
          restore-keys: |
            PUSH-${{ runner.os }}-${{matrix.node-version}}-${{matrix.package.folder}}-
            PUSH-${{ runner.os }}-${{matrix.node-version}}-
            PUSH-${{ runner.os }}-
      - name: Install Node.js dependencies
        run: npm ci --cache ~/.npm --prefer-offline --only=production --silent
      - name: Install package dependencies
        id: install
        run: lerna bootstrap --scope=${{matrix.package.name}} --include-dependencies
      - name: Build Prisma client
        id: prisma
        run: lerna run --scope=${{matrix.package.name}} prisma:generate
      - name: Build code
        id: build
        run: lerna run --scope=${{matrix.package.name}} --loglevel=silent build --include-dependencies
      - name: Format code
        id: format
        run: lerna run --scope=${{matrix.package.name}} --loglevel=silent check-format
      - name: Lint code
        id: lint
        run: lerna run --scope=${{matrix.package.name}} --loglevel=silent lint
      - name: Run tests
        id: test
        run: lerna run --scope=${{matrix.package.name}} --loglevel=silent test

  hashes:
    runs-on: ubuntu-20.04
    outputs:
      hashes: ${{ steps.service-hashes.outputs.service_hashes }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 1
      - name: 'Find folders that containing Dockerfile'
        id: find-folders
        uses: ./.github/actions/find-folders-by
        with:
          files-to-find: '["Dockerfile"]'
          folders-to-search: '[ "ee/packages",  "packages" ]'
          ignore-folders: '[  "node_modules",  "lib",  "dist",  "bin",  "src",  "__mocks__",  "public",  "scripts",  "test",  "prisma",  "graphql",  "generated" ]'
          search-recursive: true

      - name: 'Usage example'
        run: |
          echo "${{ steps.find-folders.outputs.folders }}"

      - name: get services hash
        id: service-hashes
        uses: ./.github/actions/get-services-hash
        with:
          folders-to-hash: ${{ steps.find-folders.outputs.folders }}
          hash-ignore: '["node_modules/**", "lib/**", "dist/**", "**/*.spec.ts","__tests__/**","__mocks__/**","test/**","tests/**"]'

      - name: Get the output time
        run: echo "The step output ${{ steps.service-hashes.outputs.service_hashes }}"


  docker-build:
    runs-on: ubuntu-20.04
    needs: [hashes]
    if: ${{ needs.hashes.outputs.hashes != '[]' && needs.hashes.outputs.hashes != '' }}
    timeout-minutes: 45
    strategy:
      matrix:
        service-hash-data: ${{ fromJson(needs.hashes.outputs.hashes) }}
    env:
      REPOSITORY_NAME: ${{ matrix.service-hash-data.folder }}
      IMAGE_HASH: ${{ matrix.service-hash-data.hash }}
      PACKAGE_NAME: ${{ matrix.service-hash-data.pkg }}
      SERVICE_FOLDER: ${{ matrix.service-hash-data.path }}
    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Get the output time
        run: echo "The step output ${{ toJson(matrix.service-hash-data) }}"

      - name: Get the output time
        run: echo "The step output ${{ matrix.service-hash-data.folder }}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v1

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Check if repo exist
        run: aws ecr describe-repositories --repository-names $REPOSITORY_NAME || aws ecr create-repository --repository-name $REPOSITORY_NAME

      - name: set branch-name
        run: echo "BRANCH_NAME=$(echo $GITHUB_REF_NAME | sed "s/[^a-zA-Z0-9]/-/g")" >> $GITHUB_ENV

      - name: Check if image hash tag is already exist in ECR image repository
        id: hash-tag-exist
        run: |
          set +e
          cmd="$(aws ecr describe-images --repository-name=$REPOSITORY_NAME --image-ids=imageTag=$IMAGE_HASH)"
          if [[ ! -z "$cmd" ]]
          then
            echo "tag already exist"
            echo "::set-output name=tag_exist::true"
          else
             echo "tag doesn't exist"
             echo "::set-output name=tag_exist::false"
           fi

      - name: Build, tag, and push image to Amazon ECR
        if: ${{ steps.hash-tag-exist.outputs.tag_exist == 'false' }}
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          TAG_LIST: "${{ github.run_id }},${{ github.sha }},${{ env.BRANCH_NAME }}"
        run: |
          echo "Will work from: $SERVICE_FOLDER"
          Docker_image=$ECR_REGISTRY/$REPOSITORY_NAME:$IMAGE_HASH
          echo "Docker_image: $Docker_image"
          command="docker build -f $SERVICE_FOLDER/Dockerfile . -t $Docker_image"
          echo "$command"
          $command
          docker push $Docker_image

      - name: Retag
        env:
          HASH_TAG_EXIST: ${{ steps.hash-tag-exist.outputs.tag_exist }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          TAG_LIST_SHORT: "${{ env.BRANCH_NAME }}"
          TAG_LIST_FULL: "${{ env.BRANCH_NAME }},${{ github.run_id }}"
          ECR_REPOSITORY: "${{ env.REPOSITORY_NAME }}"
        run: |
          if [[ "$HASH_TAG_EXIST" == 'true' ]]
          then
            echo "tag already exist"
            export TAG_LIST=$TAG_LIST_SHORT
          else
            echo "tag doesn't exist"
            export TAG_LIST=$TAG_LIST_FULL
          fi
          echo $TAG_LIST
          export MANIFEST=$(aws ecr batch-get-image --repository-name $REPOSITORY_NAME --image-ids imageTag=$IMAGE_HASH --output json | jq --raw-output --join-output '.images[0].imageManifest')
          echo "MANIFEST: $MANIFEST"
          sh .github/workflows/scripts/ecr_retag.sh

