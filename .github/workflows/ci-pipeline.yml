name: CI-Pipeline

on:
  workflow_dispatch:
  push:
  #   branches: [master]
  # pull_request:
  #   branches: [master]
  #   types: [opened, reopened]

jobs:
  # check-aws-resources:
  #   name: Check aws resources exist
  #   runs-on: ubuntu-latest
  #   outputs:
  #     create_folder: ${{ steps.check_chart.outputs.create_folder }}
  #   env:
  #     working-directory: amplication-charts
  #     BUCKET_NAME: "amplication-bucket"
  #     REGION: us-east-2

  #   steps:
  #     - name: Checkout 
  #       uses: actions/checkout@v2

  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v1
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # need to add secret
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # need to add secret
  #         aws-region: ${{ env.REGION }}

  #     - name: Install aws cli
  #       id: install-aws-cli
  #       uses: unfor19/install-aws-cli-action@v1.0.2
  #       with:
  #         version: 2    
  #         verbose: false 
  #         arch: amd64  
      
  #     # - name: Check if S3-bucket exist
  #     #   run: |
  #     #     if aws s3 ls s3://$BUCKET_NAME 2>&1 | grep -q 'NoSuchBucket'
  #     #     then
  #     #       aws s3api create-bucket --bucket $BUCKET_NAME --region $REGION --create-bucket-configuration LocationConstraint=$REGION
  #     #     fi

  #       ## Will be false if this is first run.
  #     - name: Check umbrella-chart folder exist
  #       id: check_chart
  #       run: |
  #         if aws s3 ls "s3://$BUCKET_NAME/amplication-charts" 2>&1 | grep -q 'NoSuchFile'
  #         then
  #           echo "No such folder in bucket" 
  #           echo "::set-output name=create_folder::true"
  #         else
  #           echo "::set-output name=create_folder::false"
  #           aws s3 cp s3://$BUCKET_NAME/amplication-charts $GITHUB_WORKSPACE --recursive
  #         fi
      
  changes:
    runs-on: ubuntu-latest
    # needs: check-aws-resources
    # if: ${{ needs.check-aws-resources.outputs.create_folder == 'false' }}
    outputs:
      # Expose matched filters as job 'apps' output variable
      apps: ${{ steps.filter.outputs.changed_files }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - uses: dorny/paths-filter@v2
        name: Detect Changes
        id: filter
        with:
          base: ${{ github.ref }}
          list-files: json
          filters: |
            changed:
              - 'packages/**'

  # first run - need to get all services folders
  get-name-all:
    runs-on: ubuntu-latest
  #   needs: [check-aws-resources]
  #   if: ${{ needs.check-aws-resources.outputs.create_folder == 'true' }}
    outputs:
      services: ${{ steps.get-service.outputs.services }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: test
        run: echo "testing"
      
      - name: get service name
        id: get-service
        run: echo "::set-output name=services::[]"
        # run: |
        #   dirs=(packages/*/)
        #   service_arr=()
        #   for d in $dirs; do service_arr+=$(echo $d | cut -d / -f 2); done
        #   echo "::set-output name=services::$service_arr"

  get-name-modified:
    runs-on: ubuntu-latest
    needs: changes
    if: ${{ needs.changes.outputs.apps != '[]' && needs.changes.outputs.apps != '' }}
    outputs:
      services: ${{ steps.set-name.outputs.services }}
    strategy:
      matrix:
        service: ${{ fromJSON(needs.changes.outputs.apps) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2
      
      - name: get service name
        id: set-name
        env: 
          SERVICE: ${{ matrix.service }}
        run: |
          echo "============= get service names ================"
          service_arr=()
          echo $SERVICE
          for d in $SERVICE; do service_arr+=$(echo $d | cut -d / -f 2); done
          echo $service_arr
          echo "============ set output ============="
          echo "::set-output name=services::$service_arr"

  install:
    runs-on: ubuntu-latest
    needs: [get-name-modified,get-name-all]
    if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
    strategy:
      matrix:
        node-version: [16.x]
        service: ${{ needs.get-name-all.outputs.services }} 
        service_modified: ${{ needs.get-name-modified.outputs.services }} 

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v2
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
    
    - name: "Install packages dependencies: ${{ matrix.service_modified }}"
      if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
      working-directory: packages/${{ matrix.service_modified }}
      run: npm run bootstrap -- --loglevel verbose

    - name: "Install packages dependencies first run: ${{ matrix.service }}"
      if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
      working-directory: packages/${{ matrix.service }}
      run: npm run bootstrap -- --loglevel verbose

  # generate:
  #   runs-on: ubuntu-latest
  #   needs: [get-name-modified,get-name-all]
  #   if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.get-name-all.outputs.services) }} 
  #       service_modified: ${{ fromJSON(needs.get-name-modified.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: Install dependencies
  #     run: npm ci

  #   - name: "Update Prisma client: ${{ matrix.service_modified }}"
  #     if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
  #     working-directory: packages/${{ matrix.service_modified }}
  #     run: npm run prisma:generate
    
  #   - name: "Update Prisma client first run: ${{ matrix.service }}"
  #     if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run prisma:generate

  
  # format:
  #   runs-on: ubuntu-latest
  #   needs: [get-name-modified,get-name-all]
  #   if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.get-name-all.outputs.services) }} 
  #       service_modified: ${{ fromJSON(needs.get-name-modified.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: Install dependencies
  #     run: npm ci
    
  #   - name: Define Lerna `SINCE` variable
  #     if: ${{ github.ref != 'refs/heads/master' }}
  #     run: echo "SINCE=origin/master" >> $GITHUB_ENV

  #   - name: "Check format: ${{ matrix.service_modified }}"
  #     if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
  #     working-directory: packages/${{ matrix.service_modified }}
  #     run: npm run check-format -- --since $SINCE
      
  #   - name: "Check format first run: ${{ matrix.service }}"
  #     if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run check-format -- --since $SINCE

  
  # lint:
  #   runs-on: ubuntu-latest
  #   needs: [get-name-modified,get-name-all]
  #   if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.get-name-all.outputs.services) }} 
  #       service_modified: ${{ fromJSON(needs.get-name-modified.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: Install dependencies
  #     run: npm ci
    
  #   - name: Define Lerna `SINCE` variable
  #     if: ${{ github.ref != 'refs/heads/master' }}
  #     run: echo "SINCE=origin/master" >> $GITHUB_ENV

  #   - name: "Lint: ${{ matrix.service_modified }}"
  #     if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
  #     working-directory: packages/${{ matrix.service_modified }}
  #     run: npm run lint -- --since $SINCE
    
  #   - name: "Lint first run: ${{ matrix.service }}"
  #     if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run lint -- --since $SINCE

  
  # build:
  #   runs-on: ubuntu-latest
  #   needs: [get-name-modified,get-name-all]
  #   if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.get-name-all.outputs.services) }} 
  #       service_modified: ${{ fromJSON(needs.get-name-modified.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: Install dependencies
  #     run: npm ci
    
  #   - name: Define Lerna `SINCE` variable
  #     if: ${{ github.ref != 'refs/heads/master' }}
  #     run: echo "SINCE=origin/master" >> $GITHUB_ENV

  #   - name: "Build packages: ${{ matrix.service_modified }}"
  #     if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
  #     working-directory: packages/${{ matrix.service_modified }}
  #     run: npm run build -- --since $SINCE

  #   - name: "Build packages first run: ${{ matrix.service }}"
  #     if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm run build -- --since $SINCE
  
  # test:
  #   runs-on: ubuntu-latest
  #   needs: [get-name-modified,get-name-all]
  #   if: always() && needs.get-name-modified.outputs.services || needs.get-name-all.outputs.services
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       service: ${{ fromJSON(needs.get-name-all.outputs.services) }} 
  #       service_modified: ${{ fromJSON(needs.get-name-modified.outputs.services) }} 

  #   steps:
  #   - name: Checkout repository
  #     uses: actions/checkout@v2

  #   - name: Use Node.js ${{ matrix.node-version }}
  #     uses: actions/setup-node@v2
  #     with:
  #       node-version: ${{ matrix.node-version }}
  #       cache: 'npm'
        
  #   - name: Install dependencies
  #     run: npm ci
    
  #   - name: Define Lerna `SINCE` variable
  #     if: ${{ github.ref != 'refs/heads/master' }}
  #     run: echo "SINCE=origin/master" >> $GITHUB_ENV

  #   - name: "Test: ${{ matrix.service_modified }}"
  #     if: ${{ matrix.service_modified != '[]' &&  matrix.service_modified != '' }}
  #     working-directory: packages/${{ matrix.service_modified }}
  #     run: npm test -- --since $SINCE

  #   - name: "Test first run: ${{ matrix.service }}"
  #     if: ${{ matrix.service != '[]' &&  matrix.service != '' }}
  #     working-directory: packages/${{ matrix.service }}
  #     run: npm test -- --since $SINCE

  # docker:
  #   name: docker
  #   needs: [get-name-all,get-name-modified,install,generate,format,lint.build,test]
  #   if: success() && (github.event_name == 'push') && always()
  #   runs-on: ubuntu-latest
  #   outputs:
  #     docker-services: ${{ steps.check-docker-service.outputs.docker-service }}
  #   strategy:
  #     matrix:
  #       node-version: [16.x]
  #       app: ${{ fromJSON(needs.changes.outputs.apps) }}
    
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v2

  #     - name: Check docker-service
  #       id: check-docker-service
  #       env: 
  #         SERVICE: ${{ matrix.app }}
  #       run: |
  #         [ -f packages/$SERVICE/Dockerfile ] && echo "$FILE exist." && echo "::set-output name=docker-service::true" || echo "$FILE does not exist." && echo "::set-output name=docker-service::false"
      
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v100
      
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v1
  #       with:
  #         aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }} # need to add secret
  #         aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }} # need to add secret
  #         aws-region: us-east-2
          
  #     - name: Login to Amazon ECR
  #       id: login-ecr
  #       uses: aws-actions/amazon-ecr-login@v1

  #     - name: Set hash
  #       if: ${{ steps.check-docker-service.outputs.docker-service == 'true' }}
  #       env:
  #         working-directory: packages/${{ matrix.app }}/Dockerfile
  #       run: echo "GITHUB_HASH=$(sha1sum $working-directory | sha1sum)" >> $GITHUB_ENV
      
  #     - name: Check if repo exist
  #       working-directory: packages/${{ matrix.app }}
  #       if: ${{ steps.check-docker-service.outputs.docker-service == 'true' }}
  #       env: 
  #         ECR_REPOSITORY: ${{ matrix.app }}
  #       run: aws ecr describe-repositories --repository-names $ECR_REPOSITORY || aws ecr create-repository --repository-name $ECR_REPOSITORY

  #     - name: Build, tag, and push image to Amazon ECR
  #       working-directory: packages/${{ matrix.app }}
  #       if: ${{ steps.check-docker-service.outputs.docker-service == 'true' }}
  #       env:
  #         ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
  #         ECR_REPOSITORY: ${{ matrix.app }}
  #         IMAGE_TAG: ${{ github.sha }}-${{ github.ref_name }}-${{ github.run_id }}-${{ env.GITHUB_HASH }}
  #       run: |
  #         docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
  #         docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
  
      
 
      


      



